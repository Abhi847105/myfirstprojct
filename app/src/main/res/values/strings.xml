<resources>
    <string name="app_name">CollageTradeHub</string>
    <string name="discrete_mathematics_objectives_of_the_course_throughout_the_course_students_will_be_expected_to_demonstrate_their_understanding_of_discrete_mathematics_by_being_able_to_do_each_of_the_following_1_use_mathematically_correct_terminology_and_notation_2_construct_correct_direct_and_indirect_proofs_3_use_division_into_cases_in_a_proof_4_use_counter_examples_5_apply_logical_reasoning_to_solve_a_variety_of_problems_detailed_contents_module_i_lecture_6_hrs_sets_relation_and_function_operations_and_laws_of_sets_cartesian_products_binary_relation_partial_ordering_relation_equivalence_relation_image_of_a_set_sum_and_product_of_functions_bijective_functions_inverse_and_composite_function_size_of_a_set_finite_and_infinite_sets_countable_and_uncountable_sets_cantor_s_diagonal_argument_and_the_power_set_theorem_schroeder_bernstein_theorem_module_2_lecture_hrs_principles_of_mathematical_induction_the_well_ordering_principle_recursive_definition_the_division_algorithm_prime_numbers_the_greatest_common_divisor_euclidean_algorithm_the_fundamental_theorem_of_arithmetic_basic_counting_techniques_inclusion_and_exclusion_pigeon_hole_principle_permutation_and_combination_module_3_lecture_8_hrs_propositional_logic_syntax_semantics_validity_and_satisfiability_basic_connectives_and_truth_tables_logical_equivalence_the_laws_of_logic_logical_implication_rules_of_inference_the_use_of_quantifiers_proof_techniques_some_terminology_proof_methods_and_strategies_forward_proof_proof_by_contradiction_proof_by_contraposition_proof_of_necessity_and_sufficiency_module_4_lecture_8_hrs_algebraic_structures_and_morphism_algebraic_structures_with_one_binary_operation_semi_groups_monoids_groups_congruence_relation_and_quotient_structures_free_and_cyclic_monod_s_and_groups_permutation_groups_substructures_normal_subgroups_algebraic_structures_with_two_binary_operation_rings_integral_domain_and_fields_boolean_algebra_and_boolean_ring_identities_of_boolean_algebra_duality_representation_of_boolean_function_disjunctive_and_conjunctive_normal_form_module_5_lecture_10_hrs_graphs_and_trees_graphs_and_their_properties_degree_connectivity_path_cycle_sub_graph_isomorphism_eulerian_and_hamiltonian_walks_graph_coloring_coloring_maps_and_planar_graphs_coloring_vertices_coloring_edges_list_coloring_perfect_graph_definition_properties_and_example_rooted_trees_trees_and_sorting_weighted_trees_and_prefix_codes_biconnected_component_and_articulation_points_shortest_distances">Discrete Mathematics Objectives of the course Throughout the course, students will be expected to demonstrate their understanding of Discrete Mathematics by being able to do each of the following 1. Use mathematically correct terminology and notation 2. Construct correct direct and indirect proofs. 3. Use division into cases in a proof. 4. Use counter examples. 5. Apply logical reasoning to solve a variety of problems. Detailed contents: Module I Lecture 6 hrs. Sets. Relation and Function: Operations and Laws of Sets. Cartesian Products. Binary Relation. Partial Ordering Relation. Equivalence Relation. Image of a Set. Sum and Product of Functions, Bijective functions. Inverse and Composite Function. Size of a Set. Finite and Infinite Sets. Countable and uncountable Sets. Cantor\'s diagonal argument and The Power Set theorem. Schroeder-Bernstein theorem. Module 2 Lecture hrs. Principles of Mathematical Induction: The Well-Ordering Principle, Recursive definition. The Division algorithm: Prime Numbers. The Greatest Common Divisor: Euclidean Algorithm. The Fundamental Theorem of Arithmetic. Basic counting techniques-inclusion and exclusion. pigeon-hole principle. permutation and combination. Module 3 Lecture 8 hrs. Propositional Logic: Syntax. Semantics. Validity and Satisfiability. Basic Connectives and Truth Tables. Logical Equivalence: The Laws of Logic. Logical Implication. Rules of Inference. The use of Quantifiers. Proof Techniques: Some Terminology. Proof Methods and Strategies. Forward Proof Proof by Contradiction. Proof by Contraposition. Proof of Necessity and Sufficiency. Module 4 Lecture 8 hrs. Algebraic Structures and Morphism: Algebraic Structures with one Binary Operation. Semi Groups. Monoids. Groups. Congruence Relation and Quotient Structures. Free and Cyclic Monod\'s and Groups. Permutation Groups. Substructures. Normal Subgroups. Algebraic Structures with two Binary Operation. Rings. Integral Domain and Fields. Boolean Algebra and Boolean Ring. Identities of Boolean Algebra. Duality. Representation of Boolean Function. Disjunctive and Conjunctive Normal Form Module 5 Lecture 10 hrs Graphs and Trees: Graphs and their properties. Degree, Connectivity. Path. Cycle. Sub Graph. Isomorphism. Eulerian and Hamiltonian Walks. Graph Coloring. Coloring maps and Planar Graphs. Coloring Vertices. Coloring Edges. List Coloring, Perfect Graph, definition properties and Example. rooted trees, trees and sorting, weighted trees and prefix codes. Biconnected component and Articulation Points. Shortest distances.</string>
    <string name="computer_organization_and_architecture_objectives_of_the_course_to_expose_the_students_to_the_following_l_how_computer_systems_work_and_the_basic_principles_2_instruction_level_architecture_and_instruction_execution_3_the_current_state_of_art_in_memory_system_design_4_how_i_o_devices_are_accessed_and_its_principles_5_to_provide_the_knowledge_on_instruction_level_parallelism_6_to_impart_the_knowledge_on_microprogramming_7_concepts_of_advanced_pipelining_techniques_detailed_contents_module_1_lecture_10_hrs_functional_blocks_of_a_computer_cpu_memory_input_output_subsystems_control_unit_instruction_set_architecture_of_a_cpu_registers_instruction_execution_cycle_rtl_interpretation_of_instructions_addressing_modes_instruction_set_case_study_instruction_sets_of_some_common_cpus_data_representation_signed_number_representation_fixed_and_floating_point_representations_character_representation_computer_arithmetic_integer_addition_and_subtraction_ripple_carry_adder_carry_look_ahead_adder_etc_multiplication_shift_and_add_booth_multiplier_carry_save_multiplier_etc_division_restoring_and_non_restoring_techniques_floating_point_arithmetic_module_2_lecture_14_hrs_introduction_to_x86_architecture_cpu_control_unit_design_hardwired_and_micro_programmed_design_approaches_case_study_design_of_a_simple_hypothetical_cpu_memory_system_design_semiconductor_memory_technologies_memory_organization_peripheral_devices_and_their_characteristics_input_output_subsystems_i_o_device_interface_1_0_transfers_program_controlled_interrupt_driven_and_dma_privileged_and_non_privileged_instructions_software_interrupts_and_exceptions_programs_and_processes_role_of_interrupts_in_process_state_transitions_i_o_device_interfaces_scil_usb_module_3_lecture_10_hrs_pipelining_basic_concepts_of_pipelining_throughput_and_speedup_pipeline_hazards_parallel_processors_introduction_to_parallel_processors_concurrent_access_to_memory_and_cache_coherency_module_4_lecture_6_hrs_memory_organization_memory_interleaving_concept_of_hierarchical_memory_organization_cache_memory_cache_size_vs_block_size_mapping_functions_replacement_algorithms_write_polices">Computer Organization and Architecture Objectives of the course To expose the students to the following: L. How Computer Systems work and the basic principles 2. Instruction Level Architecture and Instruction Execution 3. The current state of art in memory system design 4. How I/O devices are accessed and its principles. 5. To provide the knowledge on Instruction Level Parallelism 6. To impart the knowledge on microprogramming 7. Concepts of advanced pipelining techniques. Detailed contents Module 1 Lecture 10 hrs. Functional blocks of a computer: CPU. memory, Input-output subsystems. control unit. Instruction set architecture of a CPU-registers. Instruction execution cycle. RTL interpretation of instructions. addressing modes. Instruction set. Case study-instruction sets of some common CPUs. Data representation: signed number representation. fixed and floating point representations, character representation. Computer arithmetic - integer addition and subtraction, ripple carry adder, carry look ahead adder, etc. multiplication -shift-and-add. Booth multiplier carry save multiplier etc. Division restoring and non-restoring techniques. floating point arithmetic. Module 2 Lecture 14 hrs. Introduction to x86 architecture. CPU control unit design: hardwired and micro- programmed design approaches. Case study design of a simple hypothetical CPU. Memory system design: semiconductor memory technologies. memory organization. Peripheral devices and their characteristics: Input-output subsystems. I/O device Interface. 1/0 transfers-program controlled. Interrupt driven and DMA. privileged and non-privileged Instructions, software interrupts and exceptions. Programs and processes-role of Interrupts in process state transitions. I/O device Interfaces-SCIL USB Module 3 Lecture 10 hrs. Pipelining: Basic concepts of pipelining throughput and speedup, pipeline hazards. Parallel Processors: Introduction to parallel processors. Concurrent access to memory and cache coherency. Module 4 Lecture 6 hrs. Memory organization: Memory interleaving, concept of hierarchical memory organization. cache memory, cache size vs. Block size, mapping functions, replacement algorithms, write polices</string>
    <string name="operating_systems_objectives_of_the_course_1_to_learn_the_fundamentals_of_operating_systems_2_to_learn_the_mechanisms_of_os_to_handle_processes_and_threads_and_their_communication_3_to_learn_the_mechanisms_involved_in_memory_management_in_contemporary_os_4_to_gain_knowledge_on_distributed_operating_system_concepts_that_includes_architecture_mutual_exclusion_algorithms_deadlock_detection_algorithms_and_agreement_protocols_5_to_know_the_components_and_management_aspects_of_concurrency_management_6_to_learn_to_implement_simple_os_mechanisms_detailed_contents_module_1_lecture_4_hrs_introduction_concept_of_operating_systems_generations_of_operating_systems_types_of_operating_systems_os_services_system_calls_structure_of_an_os_layered_monolithic_microkernel_operating_systems_concept_of_virtual_machine_case_study_on_unix_and_windows_module_2_lecture_10_hrs_processes_definition_process_relationship_different_states_of_a_process_process_state_transitions_process_control_block_pcb_context_switching_thread_definition_various_states_benefits_of_threads_types_of_threads_concept_of_multithreads_process_scheduling_foundation_and_scheduling_objectives_types_of_schedulers_scheduling_criteria_cpu_utilization_throughput_turnaround_time_waiting_time_response_time_scheduling_algorithms_pre_emptive_and_non_pre_emptive_fcfs_sjp_rr_multiprocessor_scheduling_real_time_scheduling_rm_and_edf_module_3_lecture_6_hrs_inter_process_communication_critical_section_race_conditions_mutual_exclusion_hardware_solution_strict_alternation_peterson_s_solution_the_producer_consumer_problem_semaphores_event_counters_monitors_message_passing_shared_memory_classical_ipc_problems_reader_s_and_writer_problem_dinning_philosopher_problem_etc_module_4_lecture_4_hrs_deadlocks_definition_necessary_and_sufficient_conditions_for_deadlock_deadlock_prevention_and_deadlock_avoidance_banker_s_algorithm_deadlock_detection_and_recovery_module_5_lecture_9_hrs_memory_management_basic_concept_logical_and_physical_address_map_memory_allocation_contiguous_memory_allocation_fixed_and_variable_partition_internal_and_external_fragmentation_and_compaction_paging_and_segmentation_principle_of_operation_page_allocation_hardware_support_for_paging_protection_and_sharing_advantages_and_disadvantages_of_paging_and_segmentation_virtual_memory_basics_of_virtual_memory_hardware_and_control_structures_locality_of_reference_page_fault_working_set_dirty_page_dirty_bit_demand_paging_page_replacement_algorithms_optimal_first_in_first_out_fifo_second_chance_sc_not_recently_used_nru_and_least_recently_used_lrul">Operating Systems Objectives of the course 1. To learn the fundamentals of Operating Systems. 2. To learn the mechanisms of OS to handle processes and threads and their communication 3. To learn the mechanisms involved in memory management in contemporary OS 4. To gain knowledge on distributed operating system concepts that Includes architecture. mutual exclusion algorithms, deadlock detection algorithms and agreement protocols 5. To know the components and management aspects of concurrency management 6. To learn to implement simple OS mechanisms Detailed Contents Module 1 Lecture 4 hrs. Introduction: Concept of Operating Systems. Generations of Operating systems. Types of Operating Systems. OS Services. System Calls. Structure of an OS-Layered. Monolithic. Microkernel Operating Systems. Concept of Virtual Machine. Case study on UNIX and WINDOWS Module 2 Lecture 10 hrs. Processes: Definition. Process Relationship. Different states of a Process. Process State transitions. Process Control Block (PCB). Context switching. Thread: Definition. Various states. Benefits of threads. Types of threads. Concept of multithreads Process Scheduling: Foundation and Scheduling objectives. Types of Schedulers. Scheduling criteria: CPU utilization. Throughput. Turnaround Time. Waiting Time. Response Time: Scheduling algorithms: Pre-emptive and Non pre-emptive. FCFS. SJP. RR: Multiprocessor scheduling: Real Time scheduling: RM and EDF. Module 3 Lecture 6 hrs. Inter process Communication: Critical Section. Race Conditions. Mutual Exclusion. Hardware Solution. Strict Alternation. Peterson\'s Solution. The Producer - Consumer Problem. Semaphores. Event Counters. Monitors. Message Passing. Shared Memory. Classical IPC Problems: Reader\'s and Writer Problem. Dinning Philosopher Problem etc. Module 4 Lecture 4 hrs. Deadlocks: Definition. Necessary and sufficient conditions for Deadlock. Deadlock Prevention, and Deadlock Avoidance: Banker\'s algorithm. Deadlock detection and Recovery. Module 5 Lecture 9 hrs. Memory Management: Basic concept. Logical and Physical address map. Memory allocation : Contiguous Memory allocation - Fixed and variable partition-Internal and External fragmentation and Compaction: Paging and Segmentation: Principle of operation- Page allocation - Hardware support for paging. Protection and sharing. Advantages and Disadvantages of paging and segmentation. Virtual Memory: Basics of Virtual Memory- Hardware and control structures - Locality of reference. Page fault. Working Set. Dirty page/Dirty bit-Demand paging. Page Replacement algorithms: Optimal. First in First Out (FIFO). Second Chance (SC). Not recently used (NRU) and Least Recently used (LRUL</string>
    <string name="design_and_analysis_of_algorithm_objectives_of_the_course_l_analyze_the_asymptotic_performance_of_algorithms_write_rigorous_correctness_proofs_for_algorithms_3_demonstrate_a_familiarity_with_major_algorithms_and_data_structures_4_apply_important_algorithmic_design_paradigms_and_methods_of_analysis_3_synthesize_efficient_algorithms_in_common_engineering_design_situations_detailed_contents_module_1_lecture_10_hrs_introduction_characteristics_of_algorithm_analysis_of_algorithm_asymptotic_analysis_of_complexity_bounds_best_average_and_worst_case_behavior_performance_measurements_of_algorithm_time_and_space_trade_offs_analysis_of_recursive_algorithms_through_recurrence_relations_substitution_method_recursion_tree_method_and_masters_theorem_module_2_lecture_10_hrs_introduction_to_divide_and_conquer_paradigm_binary_search_quick_and_merge_sorting_techniques_hincur_time_selection_algorithm_strassen_s_matrix_multiplication_karatsuba_algorithm_for_fast_multiplication_etc_introduction_to_heap_min_and_max_heap_build_heap_heap_sort_module_3_lecture_10_hrs_overview_of_brute_force_greedy_programming_dynamic_programming_branch_andbound_and_backtracking_methodologies_greedy_paradigm_examples_of_exact_optimization_solution_minimum_cost_spanning_tree_knapsack_problem_job_sequencing_problem_huffman_coding_single_source_shortest_path_problem_dynamic_programming_difference_between_dynamic_programming_and_divide_and_conquer_applications_fibonacci_series_matrix_chain_multiplication_0_1_knapsack_problem_longest_common_subsequence_travelling_salesman_problem_rod_cutting_bin_packing_heuristics_characteristics_and_their_application_domains_module_4_lecture_8_hrs_graph_and_tree_algorithms_representational_issues_in_graphs_traversal_algorithms_depth_first_search_dfs_and_breadth_first_search_bfs_shortest_path_algorithms_bellman_ford_algorithm_dijkstra_s_algorithm_analysis_of_dijkstra_s_algorithm_using_heaps_floyd_warshall_s_all_pairs_shortest_path_algorithm_transitive_closure_topological_sorting_network_flow_algorithm_connected_component_module_5_lecture_5_hrs_tractable_and_intractable_problems_computability_of_algorithms_computability_classes_p_np_np_complete_and_np_hard_cook_s_theorem_standard_np_complete_problems_and_reduction_techniques_approximation_algorithms_randomized_algorithms"><![CDATA[Design and Analysis of Algorithm Objectives of the course L. Analyze the asymptotic performance of algorithms. ! Write rigorous correctness proofs for algorithms 3. Demonstrate a familiarity with major algorithms and data structures. 4. Apply Important algorithmic design paradigms and methods of analysis. 3. Synthesize efficient algorithms in common engineering design situations. Detailed contents: Module 1 Lecture 10 hrs. Introduction: Characteristics of algorithm. Analysis of algorithm: Asymptotic analysis of complexity bounds-best, average and worst-case behavior: Performance measurements of Algorithm. Time and space trade-offs. Analysis of recursive algorithms through recurrence relations: Substitution method. Recursion tree method and Masters\' theorem. Module 2 Lecture 10 hrs Introduction to Divide and Conquer paradigm: Binary Search. Quick and Merge sorting techniques. Hincur time selection algorithm. Strassen\'s Matrix Multiplication. Karatsuba Algorithm for fast multiplication etc. Introduction to Heap: Min and Max Heap. Build Heap. Heap Sort Module 3 Lecture 10 hrs Overview of Brute Force. Greedy Programming, Dynamic Programming. Branch- andBound and Backtracking methodologies. Greedy paradigm examples of exact optimization solution: Minimum Cost Spanning Tree. Knapsack problem. Job Sequencing Problem. Huffman Coding. Single source shortest path problem. Dynamic Programming difference between dynamic programming and divide and conquer. Applications: Fibonacci Series. Matrix Chain Multiplication. 0-1 Knapsack Problem. Longest Common Subsequence. Travelling Salesman Problem. Rod Cutting, Bin Packing. Heuristics-characteristics and their application domains. Module 4 Lecture 8 hrs. Graph and Tree Algorithms Representational issues in graphs. Traversal algorithms: Depth First Search (DFS) and Breadth First Search (BFS) Shortest path algorithms: Bellman-Ford algorithm. Dijkstra\'s algorithm & Analysis of Dijkstra\'s algorithm using heaps. Floyd-Warshall\'s all pairs shortest path algorithm. Transitive closure. Topological sorting Network Flow Algorithm. Connected Component Module 5 Lecture 5 hrs. Tractable and Intractable Problems: Computability of Algorithms. Computability classes -P.NP. NP-complete and NP-hard. Cook\'s theorem. Standard NP-complete problems and Reduction techniques. Approximation algorithms. Randomized algorithms]]></string>
</resources>